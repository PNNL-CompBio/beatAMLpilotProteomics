---
title: "Figure 3 Candidates signatures from LOO cross validation"
author: "Sara Gosline"
date: "02/08/2021"
output: html_document
---

```{r setup, include=FALSE,echo=FALSE,warning=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(amlresistancenetworks)
library(wesanderson)
source("../beatAMLdata.R")

if(!exists('dataLoaded')){
  loadBeatAMLData()
  #loadUnNormPhosData()
  dataLoaded=TRUE
}


```

This markdown dives into the results of the drug assessment performance, to determine how, for a particula drug, to find the best predictor of patient response. Our approach is mainly quantitative but we also employ qualitative metrics to assess the interpretability of the signature selected.


We first collected the stores results generated in `../buildAndStoreModels.R` and stored on Synapse.

```{r build sigs,warning=F,message=F}


##get file from synapse
syn<-amlresistancenetworks::synapseLogin()
eval.preds<-readRDS(syn$get('syn26533741')$path)
all.preds<-readRDS(syn$get('syn26530501')$path)

tr.dat<- pat.data%>%
    left_join(rename(pat.phos,`AML sample`='Sample',Phosphosite='LogFoldChange'))%>%
  subset(`AML sample`%in%auc.dat$`AML sample`)

```

## Evaluate Functional role of the signatures


First we rank the signatures by their performance across k-fold cross validation. We can now select the combination of predictive model and data type (combo) that best predicts drug response according to correlation across all folds of cross validation.

```{r get best predictors, message=FALSE}
  ##what is the _Best_ predictor of each drug? 
  eval.sum<-eval.preds%>%dplyr::select(compound,Molecular,method,corVal)%>%
    group_by(compound,Molecular,method)%>%
    summarize(meanCor=mean(corVal,na.rm=T))

  bestRes<-eval.sum%>%
    group_by(compound)%>%
    mutate(maxCor=max(meanCor,na.rm=T))%>%
    subset(meanCor==maxCor)%>%
    arrange(desc(meanCor))
  
  DT::datatable(bestRes)
```


For trametinib and quizartinib, logistic regression works best, on mRNA and protein combined. 


## Plot best models on data

It is important to create a generic function that will select the features from the model and plot them in heatmaps, as well as carry out functional enrichment. 

```{r lasso preds,warning=FALSE,echo=FALSE}


#'
#'selectDataMatAndPlot matches the output of a predictor (new.results) to the AUC data
#'and original molecular data to create heatmap
#'and combines ith with the specified data type and passes along a method to be used
#'@param drugName
#'@param meth
#'@param data
#'@return output of prediction

selectDataMatAndPlot<-function(drugName,method,data,genelist,doEnrich=FALSE,doGraph=FALSE){
  #get dimensionality-reduced samples
  
  ##get features from model
  data.types <- getFeaturesFromStringdf(genelist,data)
  
  ##making pretty
  pal<-wes_palette("Darjeeling2")
  dat.colors <- pal[1:4]
  names(dat.colors)<-c('Phosphosite','proteinLevels','mRNALevels','binaryMutations')
  annote.colors <- list(Datatype=dat.colors,Sensitive = c(`TRUE` = "darkgrey", `FALSE` = "white"))
    
  #prep output
  gres<- data.frame(ID = "", Description = "", pvalue = 1, 
        p.adjust = 1)
  kres<-data.frame(ID = "", Description = "", pvalue = 1, 
        p.adjust = 1)
  
  ##prep data
  res = apply(data.types,1,function(y) {
    gl=unlist(strsplit(y[['genelists']],split=';'))
    if(y[['DataType']]=='Phosphosite') 
      { 
        subset(tr.dat,site%in%gl)%>%
          dplyr::select(`AML sample`,value=Phosphosite,Gene=site)%>%
        mutate(Datatype=y[['DataType']])
      }else 
        {
          subset(tr.dat,Gene%in%gl)%>%
                   dplyr::select(`AML sample`,value=y[['DataType']],Gene)%>%
                  mutate(Datatype=y[['DataType']])
        }
    })%>%do.call(rbind,.)
  
  if(doEnrich){
    ##do enrichment of genes and sites separately
    subs<-subset(res,Datatype=='Phosphosite')
    genes<-subset(res,Datatype!='Phosphosite')
    try(gres<-doRegularGo(genes=unique(genes$Gene)))
  #print(gres)
    try(kres<-doRegularKin(genes=unique(subs$Gene))%>%
          subset(p.adjust<0.05))
  #print(kres)
  }

  if(doGraph){
    ##build graph
    gene.vals<-rep(1,nrow(subset(res,DataType=='binaryMutations')))
    names(gene.vals)<-subset(res,Datatype=='binaryMutations')$Gene
    
    
    prot.vals<-rep(1,nrow(subset(res,Datatype=='proteinLevels')))
    names(prot.vals)<-subset(res,Datatype=='proteinLevels')$Gene
    
    rna.vals<-rep(1,nrow(subset(res,Datatype=='mRNALevels')))
    names(rna.vals)<-subset(res,Datatype=='mRNALevels')$Gene
    
    phos.vals<-rep(1,nrow(subset(res,Datatype=='Phosphosite')))
    names(phos.vals)<-subset(res,Datatype=='Phosphosite')$Gene
    
    fname=paste0(drugName,'_',method,'_',data,'network.gml')
    res<-computePhosphoNetwork(phos.vals,prot.vals,gene.vals,rna.vals,fname=fname)
  }

  dupes <- which(duplicated(res$Gene))
  if(length(dupes)>0)
    res <- res%>%unite(c(Gene,Datatype),col='Gene',remove=FALSE)
                                   
  #otherwise just plot
  mat <- res%>%dplyr::select(`AML sample`,value,Gene)%>%
    pivot_wider(names_from=`AML sample`,
                values_from=value,values_fill=list(value=0.0),values_fn=mean)%>%
    tibble::column_to_rownames('Gene')
  
 # print(mat)
    auc.d<-auc.dat%>%
    subset(Condition==drugName)%>%
    dplyr::select(`AML sample`,AUC)%>%
      distinct()%>%
    #dplyr::rename(Sample='AML sample')%>%
      tibble::column_to_rownames('AML sample')%>%
      mutate(Sensitive=as.character(AUC<100))
    
    gene.d<-res%>%select(Gene,Datatype)%>%
      distinct()%>%
      tibble::column_to_rownames('Gene')
    
    library(pheatmap)
    fname=paste0(drugName,'_',method,'_',data,'expression.pdf')
    pheatmap(mat,annotation_row = gene.d,
             annotation_col=auc.d,
             annotation_colors=annote.colors,
             clustering_method='ward.D2',scale='row',
             cellwidth = 10,cellheight = 10,filename = fname)

    fres<-rbind(gres,kres)
   return(fres)
  
  }
```


We can then iterate over this function to do the plotting.


```{r evaluate functional enrichment}   

  pred.lists<-do.call(rbind,apply(all.preds,1,function(x){
    res<-getFeaturesFromStringdf(x[['genes']],x[['Molecular']])
   # print(as.data.frame(t(x)))
    res%>%left_join(as.data.frame(t(x)),by='Molecular')
  }))%>%
    select(-genes)%>%
    left_join(eval.sum)%>%
    arrange(desc(meanCor))
  
  pred.lists$numFeatures<-as.character(pred.lists$numFeatures)
    pred.lists$numSamples<-as.character(pred.lists$numSamples)

  write.csv(pred.lists,file='fullDataModelFeaturesAndPerf.csv')
  ##nanually upload for now
 ## synTableStore(pred.lists,'Regression models from all pilot data',parentId = 'syn22128879')
  
  #DT::datatable(pred.lists)
  
  new.results<-all.preds%>% 
    left_join(eval.sum)%>%
    arrange(desc(meanCor))%>%
    subset(numFeatures>2)%>%#subset(MSE<1500)%>%  
    mutate(doEnrich=TRUE)%>%
     #   subset(compound%in%c('Trametinib (GSK1120212)','Quizartinib (AC220)'))%>%
    subset(meanCor>0.5)%>%
    dplyr::select(var='compound',method,data='Molecular',genelist='genes',doEnrich)%>%
    rowwise()%>%
    mutate(enrich=paste(selectDataMatAndPlot(var,method,data,genelist,doEnrich)$Description,collapse=','))

  write.csv(new.results,'allDrugsGOenrichment.csv')

```

### Network analysis

Next we take the top-performing signatures for the two drugs of interest (trametinib and quizartinib) and plot them using the PCSF. For now let's focus on the multi-omic predictors.

```{r plot graphs}


  graph.results<-all.preds%>% 
    left_join(eval.sum)%>%
    arrange(desc(meanCor))%>%
    subset(numFeatures>2)%>%#subset(MSE<1500)%>%  
    mutate(doGraph=TRUE)%>%
    subset(compound%in%c('Trametinib (GSK1120212)','Quizartinib (AC220)'))%>%
    subset(meanCor>0.5)%>%
    dplyr::select(var='compound',method,data='Molecular',genelist='genes',doGraph)%>%
    rowwise()%>%
    mutate(enrich=paste(selectDataMatAndPlot(var,method,data,genelist,doGraph)$Description,collapse=','))

```



Now we can explore specific gene signatures based on their performance and gene sets of interest.








